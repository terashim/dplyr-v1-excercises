---
title: 'dplyr ver1 練習帳 - 13 ネストしたデータ構造'
author: "terashim"
date: "2020/7/12"
output:
  md_document:
    variant: gfm
---

# 13 ネストしたデータ構造

単純な表形式ではなくネスト構造を持つデータを扱うことができる。
なおネスト構造を扱う機能は `dplyr` ではなく `tidyr` パッケージに含まれている。

ネストしたデータでは、データフレームの中の値として再びデータフレームが含まれるようにできる。

### 公式ドキュメント

- `nest()`, `unnest()` 関数のヘルプ [Nest and unnest — nest • tidyr](https://tidyr.tidyverse.org/reference/nest.html)
- ヴィニエット [Nested data • tidyr](https://tidyr.tidyverse.org/articles/nest.html)

## なぜネストしたいのか

- データに対してグループごとに "なにか" を行うときに使える。
- `group_by()` と `summarise()` の組み合わせでは扱えない複雑な構造のデータを扱える。

### モデリングにおけるネスト構造データ

例えば、データをグループごとに分けてそれぞれに対してフィッティングを行い、モデルを作成する場面を考える。

次のようなフラットな構造の表データがあるとき

グループ  | 変数x  | 変数y  | 変数z
:---------|:-------|:-------|:-------
グループA | 値x_a1 | 値y_a1 | 値z_a1
グループA | 値x_a2 | 値y_a2 | 値z_a2
グループA | 値x_a3 | 値y_a3 | 値z_a3
 ...      | ...    | ...    | ...    
グループB | 値x_b1 | 値y_b1 | 値z_b1
グループB | 値x_b2 | 値y_b2 | 値z_b2
グループB | 値x_b3 | 値y_b3 | 値z_b3
 ...      | ...    | ...    | ...    
グループC | 値x_c1 | 値y_c1 | 値z_c1
グループC | 値x_c2 | 値y_c2 | 値z_c2
グループC | 値x_c3 | 値y_c3 | 値z_c3
 ...      | ...    | ...    | ...    

まずグループごとに変数x, y, z からなるデータフレームを作り、ネストしたデータ構造にする

グループ  | データ
:---------|:-------------------------------------------------------
グループA | データ X_a = { (x_ai, y_ai, z_ai) : i = 1, 2, 3, ... }
グループB | データ X_b = { (x_bi, y_bi, z_bi) : i = 1, 2, 3, ... }
グループC | データ X_c = { (x_ci, y_ci, z_ci) : i = 1, 2, 3, ... }
 ...      | ...

各グループごとにモデルを作成し、それもデータフレームの要素として格納できる 

グループ  | データ     | モデル
:---------|:-----------|:--------
グループA | データ X_a | モデルa 
グループB | データ X_b | モデルb
グループC | データ X_c | モデルc 
 ...      | ...        | ...

ここでデータの列やモデルの列はアトミックな値の入ったベクトルではなく、オブジェクトを並べたリストとなる。

このような形式で１つのデータフレームにまとめておくと、
[tidymodels パッケージ群](https://www.tidymodels.org/) と併用することによって
統計モデリングや機械学習におけるタスクを標準化された統一的な方法で取り扱うことが可能となる（らしい）。

---

## パッケージをロード

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(nycflights13)
```

## ネストしたデータの例

次のような3つのグループからなる階層構造のデータを考える。
各グループには表データが含まれている。

- グループ 1
    -
        x   | y
        :---|:---
        1   | 2
- グループ 2
    -
        x   | y
        :---|:---
        4   | 6
        5   | 7
- グループ 3
    -
        x   
        :---
        10

```{r}
df1 <- tibble(
  g = c(1, 2, 3),
  data = list(
    tibble(x = 1, y = 2),
    tibble(x = 4:5, y = 6:7),
    tibble(x = 10)
  )
)

df1
```

データフレーム `df1` の列 `data` はリスト型オブジェクトとなる。
リスト `df1$data` の各要素には再びデータフレームが入っている。

```{r}
df1$data
class(df1$data)
```

```{r}
df1$data[[2]]
class(df1$data[[2]])
```

## フラットな表データからネストしたデータを作る `nest()`

次のような 4行 x 3列のテーブル型データ `df2` があるとする。

```{r}
df2 <- tribble(
  ~g, ~x, ~y,
   1,  1,  2,
   2,  4,  6,
   2,  5,  7,
   3, 10,  NA
)
df2
```

（ここで `tribble` はデータフレームの要素をわかりやすく行方向に並べて書くための関数）

列 `g` がグループを表している。 `g == 2` の行が２つある。

このデータに対して `nest()` を使うと、グループ `g` ごとに列 `x`, `y` からなるデータフレームにまとめたネスト構造のデータに変換される:

```{r}
df2 %>% nest(data = c(x, y))
```

`g` は 3つの値を取るので、変換後のデータフレームは 3行 x 2列 になる。
`data` 列の各要素には `x`, `y` の2列からなるデータフレームが入っている。

## `nest()` + `group_by()`

列 `x`, `y` を指定する代わりに, `group_by` でグループ化用の変数 `g` を指定しても良い:

```{r}
df2 %>% group_by(g) %>% nest()
```

## `unnest()` でネストを解除する

`unnest()` は `nest()` の逆を行う関数で、ネストしたデータをフラットな表データに変換する

```{r}
df1 %>% unnest(data)
```

## ネストしたデータに対する操作

ネストしたデータフレーム `df1` に対して、列 `data` に格納された各データフレームの行数を計算し、列 `nrow` としたい。

データフレームに列を追加するので `dplyr::mutate()` を使う。
その中で各データフレームの行数を計算する操作を記述する必要がある。

この操作の入力はデータフレームのリスト `df1$data` であり、
出力はリスト内の各データフレームの行数を並べたベクトルである。
つまり次のようなベクトルを作りたい:

```{r}
c(
  nrow(df1$data[[1]]),
  nrow(df1$data[[2]]),
  nrow(df1$data[[3]])
)
```

リスト `df1$data` の各要素に同じ関数 `nrow()` を適用したい。
このような場合は `purrr` パッケージの `map()` 関数が使える。

`purrr::map()` 関数はリストの各要素に対して関数を適用した結果をまたリストとして返す。
Python における [`map` 関数](https://docs.python.org/ja/3.8/library/functions.html?highlight=map#map) や
JavaScript における [`Array` の `map` メソッド](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/map) と同様の機能である。

```{r}
library(purrr)
map(df1$data, nrow)
```

結果が整数になると分かっていて、リスト型ではなく整数ベクトルで返したい場合は、`purrr::map_int()` を使う: 

```{r}
map_int(df1$data, nrow)
```

これで所望のベクトルの作り方が分かった。

最後に `mutate()` と組み合わせると次のように書ける:

```{r}
df1 %>% 
  mutate(nrow = map_int(data, nrow))
```
