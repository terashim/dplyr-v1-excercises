---
title: 'dplyr ver1 練習帳 - 13-2 ネストしたデータ構造の活用 その２ モデル作成'
author: "terashim"
date: "2020/7/14"
output:
  md_document:
    variant: gfm
---

# 13-2 ネストしたデータ構造の活用 その２ モデル作成

### グループごとのモデル作成とネスト構造データ

データをグループごとに分けてから、それぞれに対してフィッティングを行ってモデルを作成する場面を考える。

次のようなフラットな構造の表データがあるとき

グループ  | 変数x  | 変数y  | 変数z
:---------|:-------|:-------|:-------
グループA | 値x_a1 | 値y_a1 | 値z_a1
グループA | 値x_a2 | 値y_a2 | 値z_a2
グループA | 値x_a3 | 値y_a3 | 値z_a3
 ...      | ...    | ...    | ...    
グループB | 値x_b1 | 値y_b1 | 値z_b1
グループB | 値x_b2 | 値y_b2 | 値z_b2
グループB | 値x_b3 | 値y_b3 | 値z_b3
 ...      | ...    | ...    | ...    
グループC | 値x_c1 | 値y_c1 | 値z_c1
グループC | 値x_c2 | 値y_c2 | 値z_c2
グループC | 値x_c3 | 値y_c3 | 値z_c3
 ...      | ...    | ...    | ...    

まずグループごとに変数x, y, z からなるデータフレームを作り、ネストしたデータ構造にする

グループ  | データ
:---------|:---------------------------------------------------------------
グループA | データフレーム X_a = { (x_ai, y_ai, z_ai) │ i = 1, 2, 3, ... }
グループB | データフレーム X_b = { (x_bi, y_bi, z_bi) │ i = 1, 2, 3, ... }
グループC | データフレーム X_c = { (x_ci, y_ci, z_ci) │ i = 1, 2, 3, ... }
 ...      | ...

各グループごとにモデルを作成し、それもデータフレームの要素として格納できる 

グループ  | データ             | モデル
:---------|:-------------------|:--------
グループA | データフレーム X_a | モデルa 
グループB | データフレーム X_b | モデルb
グループC | データフレーム X_c | モデルc 
 ...      | ...                | ...

ここでデータの列やモデルの列はアトミックな値の入ったベクトルではなく、オブジェクトを並べたリストとなる。

このような形式で１つのデータフレームにまとめておくと、
[tidymodels パッケージ群](https://www.tidymodels.org/) と併用することによって
統計モデリングや機械学習におけるタスクを標準化された統一的な方法で取り扱うことが可能となる（らしい）。

## モデルの作成

パッケージ `tidyr`, `dplyr` をロードする

```{r}
library(tidyr)
library(dplyr)
```

サンプルデータとして `mtcars` を使用する

```{r}
tibble(mtcars)
```

`mtcars` の列 `cyl`（気筒数）は 4, 6, 8 の３種類の値を取る。これによってデータを３つに分け、ネストした構造にする

```{r}
mtcars %>%
  group_by(cyl) %>%
  nest()
```

`cyl` ごとにグループ分けされたデータのそれぞれに対して、
`mpg` 対 `wt` の線形回帰モデルでフィッティングする。
得られた３つのモデルを列 `models` の各行に格納する:

```{r}
data_models <- 
  mtcars %>%
  group_by(cyl) %>%
  nest() %>%
  mutate(models = purrr::map(data, function(df) lm(mpg ~ wt, data = df)))
```

```{r}
data_models
```

例えば１行目に格納されたデータ、モデルにアクセスするには次のようにする

```{r}
data_models$data[[1]]
data_models$models[[1]]
```

## 各モデルを１行で要約 - `broom::glance.lm()`

`tidymodels` の例として
`broom` パッケージの `glance()` 関数を扱う.

`glance()`  関数を `lm` オブジェクト（線形回帰モデル）に適用すると、そのモデルの要約情報が1行のデータフレームで返される:

```{r}
library(broom)

model <- data_models$models[[1]]
glance(model)
```

複数のモデルのリストに適用すれば、１つのデータフレームでモデルの特徴を互いに比較することができる:

```{r}
purrr::map_dfr(
  data_models$models,
  glance
)
```

ネストしたデータを使えば、次のように書ける:

```{r}
data_models %>% 
  mutate(glanced = purrr::map(models, glance)) %>% 
  unnest(glanced)
```
